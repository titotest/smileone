<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Remorph Design</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@900&display=swap">
    <style>
        /* === Global Styles === */
        /* Define CSS variables for font sizes and transitions */
        :root {
            --title-font-size: 5vmin; /* Title font size scales with shortest viewport axis */
            --menu-font-size: 4vmin; /* Menu item font size scales with shortest viewport axis */
            --menu-font-size-tapped: calc(var(--menu-font-size) * 0.8); /* Reduced font size when tapped */
            --transition-duration: 0.5s; /* Duration for menu slide and title positioning animations */
            --safe-area-top: env(safe-area-inset-top, 0); /* Fallback to 0 if not supported */
            --viewport-height: 100vh; /* Fallback for dynamic viewport height */
        }

        /* Support for dynamic viewport height (dvh) */
        @supports (height: 100dvh) {
            :root {
                --viewport-height: 100dvh;
            }
        }

        /* In portrait mode, scale font sizes with viewport height for better proportionality */
        @media (orientation: portrait) {
            :root {
                --title-font-size: 5vmax; /* Scales with viewport height (longer axis) */
                --menu-font-size: 4vmax;
                --menu-font-size-tapped: calc(var(--menu-font-size) * 0.8);
            }
        }

        /* Reset default margins and ensure full viewport height */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: var(--viewport-height); /* Dynamic viewport height to exclude browser UI */
            min-height: var(--viewport-height); /* Ensure compatibility */
            font-family: 'Nunito', Arial, sans-serif; /* Font stack with fallback */
            background: black; /* Black background */
            overflow: hidden; /* Prevent scrolling */
            overscroll-behavior: none; /* Disable pull-to-refresh on mobile */
        }

        /* === Container === */
        /* Center container for title and menu */
        .container {
            height: var(--viewport-height); /* Match dynamic viewport height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* === Title === */
        /* Title styling and positioning */
        .title {
            font-size: var(--title-font-size);
            color: #f5f5f7; /* Updated text color */
            font-weight: 900;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(0deg) scale(1); /* Initial transform state */
            white-space: nowrap; /* Prevent text wrapping */
            backface-visibility: hidden; /* Optimize transform animations */
            z-index: 2; /* Ensure title is above menu */
            will-change: top, transform; /* Optimize animation performance */
            transition: top var(--transition-duration) ease, transform var(--transition-duration) ease; /* Smooth top and transform changes */
        }

        /* Move title to top when menu is visible, account for safe area */
        .title.at-top {
            top: calc(var(--title-font-size) + var(--safe-area-top)); /* Add safe area inset */
            transform: translateX(-50%) rotate(0deg) scale(1); /* Maintain rotation/scale state */
        }

        /* Ensure title stays visible in landscape mode with small viewport height */
        @media (orientation: landscape) and (max-height: 400px) {
            .title.at-top {
                top: calc(var(--title-font-size) * 0.5 + var(--safe-area-top)); /* Reduce top spacing */
            }
        }

        /* === Menu === */
        /* Menu container, initially hidden below viewport */
        .menu {
            position: absolute;
            top: 100%; /* Start below viewport */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            visibility: hidden;
            will-change: top, transform, opacity, visibility; /* Optimize animation performance */
            transition: top var(--transition-duration) ease, transform var(--transition-duration) ease, opacity var(--transition-duration) ease, visibility var(--transition-duration) ease; /* Slide and fade animation */
            width: 100%;
            z-index: 1; /* Below title */
        }

        /* Show menu by sliding up to center */
        .menu.visible {
            top: 50%;
            transform: translate(-50%, -50%);
            opacity: 1;
            visibility: visible;
        }

        /* Menu list styling */
        .menu-list {
            display: flex;
            flex-direction: column;
            align-items: center;
            list-style: none;
            padding: 0;
            gap: calc(var(--menu-font-size) * 0.4); /* Gap matches visual text height (tuned for Nunito's cap height); adjust to 0.3 or 0.35 if needed */
            max-height: calc(var(--viewport-height) - var(--title-font-size) * 2 - var(--safe-area-top)); /* Fit below title, account for safe area */
        }

        /* Individual menu items */
        .menu-item {
            font-size: var(--menu-font-size);
            color: #f5f5f7; /* Updated text color */
            font-weight: 900;
            text-align: center;
            text-decoration: none;
            transition: font-size 0.1s ease, transform 0.1s ease, background-color 0.1s ease; /* Smooth tap effects */
            white-space: nowrap; /* Prevent wrapping */
        }

        /* Reduce font size and scale down when tapped */
        .menu-item.tapped {
            font-size: var(--menu-font-size-tapped);
            transform: scale(0.95); /* Slight scale down for tap feedback */
        }

        /* === Fornoobies Animation === */
        /* "heho" animation at the bottom of the screen */
        .fornoobies {
            position: absolute;
            bottom: calc(var(--title-font-size) * 0.5); /* Space from bottom, half of title font size */
            left: 50%;
            transform: translateX(-50%);
            font-size: calc(var(--title-font-size) * 0.5); /* Half of title font size */
            font-family: 'Nunito', Arial, sans-serif;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.5); /* White with 50% opacity */
            display: flex; /* Inline "he" and "ho" */
            white-space: nowrap;
            z-index: 1; /* Below title */
        }

        .fornoobies.hidden {
            display: none; /* Hidden by default */
        }

        .he, .ho {
            opacity: 0; /* Start invisible */
            cursor: pointer; /* Indicate clickability */
        }

        .fornoobies.show .he {
            animation: fadeInHold 0.7s ease forwards; /* Fade in and hold, then disappear instantly */
        }

        .fornoobies.show .ho {
            animation: holdFadeOut 0.7s ease forwards;
            animation-delay: 0.7s; /* Start instantly after "he" */
        }

        @keyframes fadeInHold {
            0% { opacity: 0; }
            42.86% { opacity: 1; } /* Fade in over 0.3s (0 to 0.3s) */
            99.99% { opacity: 1; } /* Hold until just before 0.7s (0.3s to 0.7s) */
            100% { opacity: 0; } /* Instantly disappear at 0.7s */
        }

        @keyframes holdFadeOut {
            0% { opacity: 1; } /* Appear instantly at 0.7s */
            57.14% { opacity: 1; } /* Hold for 0.4s (0.7s to 1.1s) */
            100% { opacity: 0; } /* Fade out over 0.3s (1.1s to 1.4s) */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="title" class="title">REMORPH DESIGN</h1>
        <nav id="menu" class="menu">
            <ul class="menu-list">
                <li><div class="menu-item">OVERVIEW</div></li>
                <li><div class="menu-item">SPECS</div></li>
                <li><div class="menu-item">PHOTOS</div></li>
                <li><a href="https://www.youtube.com/@RemorphDesign" class="menu-item">VIDEOS</a></li>
                <li><div class="menu-item">3D</div></li>
                <li><div class="menu-item">FILES</div></li>
                <li><div class="menu-item">DISCORD</div></li>
            </ul>
        </nav>
        <div class="fornoobies hidden">
            <span class="he">he</span><span class="ho">ho</span>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Element references with error handling
            const title = document.getElementById('title');
            const menu = document.getElementById('menu');
            const fornoobies = document.querySelector('.fornoobies');
            const he = document.querySelector('.he');
            const ho = document.querySelector('.ho');
            if (!title || !menu || !fornoobies || !he || !ho) {
                console.error('Required elements not found: title, menu, fornoobies, he, or ho');
                return;
            }

            // State variables
            let isSmiley = false; // Tracks if title is showing ":-)"
            let isMenuVisible = history.state?.menuVisible || false; // Initialize from history state (null on refresh)
            let isAnimating = false; // Prevents animation conflicts
            let currentRotation = 0; // Tracks title rotation angle
            let timeoutId = null; // Stores timeout for smiley revert
            let touchStartY = 0; // Tracks touch start position for swipe
            const swipeThreshold = 50; // Minimum swipe distance to toggle menu

            // Fornoobies feature state
            const fornoobiesMode = true; // Kill switch: set to false to disable fornoobies feature
            let hasMenuBeenShown = isMenuVisible; // Track if menu has been shown (init from history)
            let idleTimeout; // Timer for inactivity detection

            // Debounce utility for resize events
            const debounce = (func, wait) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func(...args), wait);
                };
            };

            // Update layout based on menu visibility
            const updateLayout = () => {
                title.classList.toggle('at-top', isMenuVisible); // Move title to top if menu is visible
                menu.classList.toggle('visible', isMenuVisible); // Show/hide menu
                if (!isSmiley) {
                    currentRotation = 0;
                    title.style.transition = 'top var(--transition-duration) ease, transform var(--transition-duration) ease';
                    title.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg) scale(1)`; // Ensure starting transform
                }
            };

            // Reset title to "REMORPH DESIGN" with a quick transition
            const resetTitle = () => {
                isSmiley = false;
                clearTimeout(timeoutId);
                timeoutId = null;
                isAnimating = false;
                currentRotation = 0;
                title.textContent = 'REMORPH DESIGN';
                title.style.width = ''; // Clear fixed width
                title.style.transition = 'transform 0.1s ease'; // Quick reset transition
                title.style.transform = isMenuVisible
                    ? `translateX(-50%) rotate(${currentRotation}deg) scale(1)`
                    : `translate(-50%, -50%) rotate(${currentRotation}deg) scale(1)`;
                title.offsetHeight; // Force reflow to ensure transition
                title.style.transition = 'top var(--transition-duration) ease, transform var(--transition-duration) ease'; // Restore default transition
            };

            // Toggle menu visibility and update history state
            const toggleMenu = () => {
                isMenuVisible = !isMenuVisible;
                hasMenuBeenShown = true; // Mark that menu has been shown
                fornoobies.classList.add('hidden'); // Instantly hide fornoobies on scroll
                resetTitle(); // Reset title on any scroll
                updateLayout();
                // Update history state without changing URL
                history.pushState({ menuVisible: isMenuVisible }, '', window.location.href);
                resetIdleTimer(); // Reset fornoobies timer
            };

            // Update title rotation and scale for animation
            const updateRotation = (targetRotation, duration, scale) => {
                if (isAnimating) return;
                isAnimating = true;
                // Normalize rotation to avoid large values
                while (currentRotation > targetRotation) {
                    currentRotation -= 360;
                }
                currentRotation = targetRotation;
                title.style.transition = `transform ${duration}s ease`;
                title.style.transform = isMenuVisible
                    ? `translateX(-50%) rotate(${currentRotation}deg) scale(${scale})`
                    : `translate(-50%, -50%) rotate(${currentRotation}deg) scale(${scale})`;
                title.offsetHeight; // Force reflow to ensure transition
            };

            // Handle title click to trigger smiley animation
            const handleTitleClick = () => {
                if (isMenuVisible || isAnimating) return;
                
                if (!isSmiley) {
                    const width = title.offsetWidth + 'px';
                    title.style.width = width; // Fix width to prevent layout shift
                    title.textContent = ':-)';
                    isSmiley = true;
                    updateRotation(90, 0.2, 1.2); // Rotate 90째 clockwise, scale up
                    timeoutId = setTimeout(() => {
                        if (!isMenuVisible) {
                            title.textContent = 'REMORPH DESIGN';
                            title.style.width = '';
                            isSmiley = false;
                            updateRotation(0, 0.2, 1); // Rotate back 90째 counterclockwise
                            timeoutId = null;
                        }
                    }, 1000);
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                    title.textContent = 'REMORPH DESIGN';
                    title.style.width = '';
                    isSmiley = false;
                    updateRotation(360, 0.4, 1); // Complete 270째 clockwise to 360째
                }
            };

            // Reset rotation after full circle animation
            title.addEventListener('transitionend', (e) => {
                if (e.propertyName === 'transform' && currentRotation === 360) {
                    currentRotation = 0;
                    title.style.transition = 'none';
                    title.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg) scale(1)`;
                    setTimeout(() => {
                        title.style.transition = `top var(--transition-duration) ease, transform var(--transition-duration) ease`;
                    }, 0);
                }
                isAnimating = false;
            });

            // Fornoobies animation: Show "heho" after 3s inactivity, repeat every 6s
            const startIdleTimer = () => {
                if (!fornoobiesMode) return; // Kill switch: do nothing if disabled
                idleTimeout = setTimeout(() => {
                    if (!isMenuVisible && !hasMenuBeenShown) {
                        // Show "heho" animation
                        fornoobies.classList.remove('hidden');
                        fornoobies.classList.remove('show'); // Reset animation
                        fornoobies.offsetHeight; // Force reflow to restart animation
                        fornoobies.classList.add('show');
                        // Hide after animation (1.4s total duration)
                        setTimeout(() => {
                            fornoobies.classList.add('hidden');
                        }, 1400);
                        // Repeat every 6s (subtract 1.4s animation duration)
                        setTimeout(startIdleTimer, 6000 - 1400);
                    }
                }, 3000);
            };

            // Reset the idle timer on user interaction
            const resetIdleTimer = () => {
                if (!fornoobiesMode) return; // Kill switch: do nothing if disabled
                clearTimeout(idleTimeout);
                startIdleTimer();
            };

            // Handle wheel scroll to toggle menu
            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0 && isMenuVisible) toggleMenu(); // Scroll up: hide menu
                else if (e.deltaY > 0 && !isMenuVisible) toggleMenu(); // Scroll down: show menu
            }, { passive: false });

            // Handle touch swipe to toggle menu
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
                resetIdleTimer();
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touchEndY = e.touches[0].clientY;
                const deltaY = touchStartY - touchEndY;
                if (Math.abs(deltaY) > swipeThreshold) {
                    if (deltaY < 0 && isMenuVisible) toggleMenu(); // Swipe up: hide menu
                    else if (deltaY > 0 && !isMenuVisible) toggleMenu(); // Swipe down: show menu
                }
            }, { passive: false });

            // Title click interaction
            title.addEventListener('click', () => {
                handleTitleClick();
                resetIdleTimer();
            });

            // Menu item interactions (tap, click)
            document.querySelectorAll('.menu-item').forEach(item => {
                const handlePressStart = () => item.classList.add('tapped');
                const handlePressEnd = () => item.classList.remove('tapped');
                const handleClick = () => {
                    if (!item.href) console.log(`${item.textContent} clicked!`); // Placeholder for future functionality
                    resetIdleTimer();
                };

                item.addEventListener('mousedown', handlePressStart);
                item.addEventListener('mouseup', handlePressEnd);
                item.addEventListener('mouseleave', handlePressEnd);
                item.addEventListener('touchstart', (e) => {
                    if (!item.href) e.preventDefault();
                    handlePressStart();
                }, { passive: false });
                item.addEventListener('touchend', (e) => {
                    if (!item.href) e.preventDefault();
                    handlePressEnd();
                }, { passive: false });
                item.addEventListener('touchcancel', handlePressEnd);
                item.addEventListener('click', handleClick);
            });

            // Fornoobies click/tap interaction: clicking "he" or "ho" toggles menu
            const handleFornoobiesClick = () => {
                if (!isMenuVisible) toggleMenu(); // Show menu if not visible
            };

            he.addEventListener('click', handleFornoobiesClick);
            ho.addEventListener('click', handleFornoobiesClick);
            he.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleFornoobiesClick();
            }, { passive: false });
            ho.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleFornoobiesClick();
            }, { passive: false });

            // Handle back/forward navigation to restore menu state
            window.addEventListener('popstate', (e) => {
                const menuVisible = e.state?.menuVisible || false;
                if (isMenuVisible !== menuVisible) {
                    isMenuVisible = menuVisible;
                    hasMenuBeenShown = isMenuVisible; // Sync fornoobies state
                    updateLayout();
                }
            });

            // Handle window resize with debouncing
            window.addEventListener('resize', debounce(() => {
                updateLayout();
                resetIdleTimer();
            }, 100));

            // Start the idle timer for fornoobies animation
            startIdleTimer();
            updateLayout(); // Initial layout setup based on history state
        });
    </script>
</body>
</html>